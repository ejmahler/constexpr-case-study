{
  "name": "Dct",
  "tagline": "A case study in the shortfalls of c++14 constexpr",
  "body": "# Introduction\r\nI think c++ constexpr is really cool, but it has a few flaws. In exploring it over the last few weeks, I've discovered some shortfalls that prevent it from being fully usable for a use case of mine. In this article, I'll explore what my use case is, what went wrong, and how compilers and the C++ standard can change to make constexpr more useful.\r\n\r\n# Motivation\r\nI'm the maintainer of a small library called [SplineLibrary](https://github.com/ejmahler/SplineLibrary). This library provides open source implementations of popular splines like the catmull-rom spline, cubic b-spline etc, and provides some useful algorithms for getting useful information from them.\r\n\r\nOne useful piece information one might want from a spline is arc length: Given two points on the spline, how far do you have to travel along to go from one to the other? The arc length formula requires a numeric integral.\r\n\r\n[/spline_library/utils/calculus.h](https://github.com/ejmahler/SplineLibrary/blob/63dfdd9e8e61032fd8ff8cbd6bab4b3bc9568c8b/spline_library/utils/calculus.h) shows an attempt at a fast implementation of [Gauss-Legendre Quadrature](https://en.wikipedia.org/wiki/Gaussian_quadrature), a popular integration algorithm. Here's an implementation:\r\n\r\n    template<class Function>\r\n    float gaussLegendreQuadrature(Function f, float a, float b)\r\n    {\r\n        const size_t NUM_POINTS = 5;\r\n\r\n        std::array<float , NUM_POINTS> quadraturePoints = {\r\n             0.0000000000000000,\r\n             0.5384693101056831,\r\n            -0.5384693101056831,\r\n             0.9061798459386640,\r\n            -0.9061798459386640\r\n        };\r\n\r\n        std::array<float , NUM_POINTS> quadratureWeights = {\r\n            0.5688888888888889,\r\n            0.4786286704993665,\r\n            0.4786286704993665,\r\n            0.2369268850561891,\r\n            0.2369268850561891\r\n        };\r\n\r\n        float halfDiff = (b - a) / 2;\r\n        float halfSum = (a + b) / 2;\r\n\r\n        float sum(0);\r\n        for(size_t i = 0; i < NUM_POINTS; i++)\r\n        {\r\n            sum += quadratureWeights[i] * f(halfDiff * quadraturePoints[i] + halfSum);\r\n        }\r\n        return halfDiff * sum;\r\n    }\r\n\r\nIt's a very simple algorithm: Copy and paste a bunch of numbers into the points and weights arrays, evaluate the integrand with each of `points[i],` then multiply the result by the corresponding `weight[i]`. Return the overall sum. The numbers you copy+paste depend only on the chosen value of `NUM_POINTS`.\r\n\r\nCopy+pasting a bunch of numbers is pretty lame. The precision you get out of the algorithm is determined by the value of `NUM_POINTS` (IE, increase `NUM_POINTS` and your integral is more accurate), so if you need more precision, you have to copy+paste an entirely new set of numbers into your code. It's unmaintainable, unweildy, and if you make an error in pasting these numbers, it's hard to spot.\r\n\r\nBut those numbers don't come from nowhere, they come from a well-known mathematical formula. **What if, instead of pasting the result of the formula into the point and weight arrays, we run the formula at compile time, and store the results for use at run-time?** The run-time code won't know the difference in terms of performance, and once it's set up it'll be much easier for programmers to use and change and debug.\r\n\r\nGiven that constexpr is all about declaring that a function can be run at compile-time, the way forward seems clear: Write a constexpr function that computes and returns the list of points for a given `NUM_POINTS`, and a second constexpr function that compute returns the list of weights for a given `NUM_POINTS`. To make changing `NUM_POINTS` easier, I'm going to implement them as template functions:\r\n\r\n    template<size_t N>\r\n    constexpr std::array<float, N> gaussLegendrePoints(void);\r\n\r\n    template<size_t N>\r\n    constexpr std::array<float, N> gaussLegendrePoints(void);\r\n\r\n# The Code\r\nThere's a very small snag: The weight formula for Gauss-Legendre Quadrature is really complicated. It requires finding all the roots of a polynomial of degree `NUM_POINTS`, which would require too much code to be worth implementing for such a small application.\r\n\r\nThankfully, there is a very similar algorithm, called [Clenshaw-Curtis Quadrature](https://en.wikipedia.org/wiki/Clenshaw%E2%80%93Curtis_quadrature), whose point and weight formulas can be expressed in less than 50 LOC. For this section I'm going to focus on how to implement Clenshaw-Curtis Quadrature using constexpr.\r\n\r\nThe core of the algorithm is almost identical to Gauss-Legendre Quadrature:\r\n\r\n    template<size_t N, class Function>\r\n    float ejmahler_integration::integrateClenshawCurtis(Function integrand, float a, float b)\r\n    {\r\n        constexpr std::array<float, N/2+1> quadraturePoints = clenshawCurtisPoints<N>();\r\n        constexpr std::array<float, N/2+1> quadratureWeights = clenshawCurtisWeights<N>();\r\n\r\n        float halfDiff = (b - a) / 2;\r\n        float halfSum = (a + b) / 2;\r\n\r\n        float sum(0);\r\n        for(size_t i = 0; i < N/2; i++)\r\n        {\r\n            sum += quadratureWeights[i] * (integrand(halfSum + halfDiff * quadraturePoints[i]) + integrand(halfSum - halfDiff * quadraturePoints[i]));\r\n        }\r\n\r\n        //the final element in quadraturePoints will always be zero. so if we compute it inside the loop it'll be double-evaluated\r\n        sum += quadratureWeights[N/2] * integrand(halfSum);\r\n        return halfDiff * sum;\r\n    }\r\n\r\nNote the \"constexpr\" next to the std::array declarations: This will force the compiler to evaluate those functions at compile time. (Of course, this is only legal if `clenshawCurtisPoints` and `clenshawCurtisWeights` are defined to be constexpr!)\r\n\r\nThe point formula is straightforward:\r\n\r\n    template<size_t N>\r\n    constexpr std::array<float, N/2+1> clenshawCurtisPoints(void)\r\n    {\r\n        std::array<float, N/2+1> result{};\r\n\r\n        for(size_t i = 0; i <= N/2; i++)\r\n        {\r\n            result[i] = std::cos(i * float(M_PI) / N);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\nThere's more code, but at this point, we're already stuck. Despite being a perfect fit for constexpr, our point function doesn't compile.\r\n\r\n# Roadblocks\r\nThere's more than one problem standing in our way: The first is compiler compatibility issues, the second is holes in the standard regarding constexpr, and the third relates to our use of `std::cos`.\r\n\r\n## Compiler Compatibility\r\n### g++\r\nI first tried this on gcc (version 5.3.1). When you try to compile the above code, you get an error similar to this:\r\n\r\n    clenshaw_curtis_quadrature.h:48:41: note: ‘constexpr std::array<float, ((N / 2) + 1)> clenshawCurtisPoints() [with long unsigned int N = 8ul]’ is not usable as a constexpr function because:\r\n                                         ^\r\n    clenshaw_curtis_quadrature.h:48:41: sorry, unimplemented: unexpected AST of kind loop_expr\r\n\r\nIt turns out gcc doesn't support loops inside constexpr functions yet. There is a ticket open for this problem [here](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68530). It looks like a patch has been written to fix the problem, so hopefully we'll see it in the next release. Until then, we can't use gcc if we want to implement this.\r\n\r\n### vc++\r\nVisual Studio 2015 Update 2 stops us even sooner: 'error C3250: 'result': declaration is not allowed in 'constexpr' function body'\r\n\r\nA quick check of Microsoft's [c++14 support page](https://msdn.microsoft.com/en-us/library/hh567368.aspx#cpp14table) shows that they haven't implemented support for c++14 relaxed constexpr yet. I know Microsoft has been infamously behind on c++11 and c++14 features, so I don't have a lot of hope for this being supported soon.\r\n\r\n### clang++\r\nThankfully, clang 3.8.0 produces no compatibility-related errors.\r\n\r\nInstead, when we try to compile our code, we get the following:\r\n\r\n    ./clenshaw_curtis_quadrature.h:54:9: note: non-constexpr function 'operator[]' cannot be used in a constant expression\r\n        result[i] = std::cos(i * floating_t(M_PI) / N);\r\n\r\nThis is not a compatibility issue -- clang is adhering to the standard. This leads us to...\r\n\r\n## C++ Standard Shortcomings\r\nIn c++14, the non-const version of `std::array::operator[]` is not constexpr. In fact, no member fuctions which modify a std::array are constexpr. According to [this c++17 proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0107r0.pdf) this was simply an oversight, rather than a conscious decision. Hopefully the proposal will be accepted and c++17 will specify `operator[]` to be constexpr.\r\n\r\n# Conclusion\r\nThis is the conclusion section.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}